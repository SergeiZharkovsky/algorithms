"""
Тимофей решил организовать соревнование по спортивному программированию,
чтобы найти талантливых стажёров.
Задачи подобраны, участники зарегистрированы, тесты написаны.
Осталось придумать, как в конце соревнования будет определяться победитель.
Каждый участник имеет уникальный логин. Когда соревнование закончится,
к нему будут привязаны два показателя:
количество решённых задач Pi и размер штрафа Fi.
Штраф начисляется за неудачные попытки и время, затраченное на задачу.
Тимофей решил сортировать таблицу результатов следующим образом: при сравнении
двух участников выше будет идти тот, у которого решено больше задач.
При равенстве числа решённых задач первым идёт участник с меньшим штрафом.
Если же и штрафы совпадают, то первым будет тот, у которого логин идёт раньше
в алфавитном (лексикографическом) порядке.
Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин.
В своё отсутствие он поручил вам реализовать алгоритм быстрой сортировки
(англ. quick sort) для таблицы результатов.
Так как Тимофей любит спортивное программирование и не любит зря расходовать
оперативную память, то ваша реализация сортировки не может потреблять O(n)
дополнительной памяти для промежуточных данных
(такая модификация быстрой сортировки называется "in-place").
Как работает in-place quick sort
Как и в случае обычной быстрой сортировки, которая использует дополнительную
память, необходимо выбрать опорный элемент (англ. pivot),
а затем переупорядочить массив.
Сделаем так, чтобы сначала шли элементы, не превосходящие опорного,
а затем —– большие опорного.
Затем сортировка вызывается рекурсивно для двух полученных частей.
Именно на этапе разделения элементов на группы в обычном алгоритме используется
дополнительная память. Теперь разберёмся, как реализовать этот шаг in-place.
Пусть мы как-то выбрали опорный элемент. Заведём два указателя left и right,
которые изначально будут указывать на левый и правый концы отрезка соотв-но.
Затем будем двигать левый указатель вправо до тех пор,
пока он указывает на элемент, меньший опорного.
Аналогично двигаем правый указатель влево, пока он стоит на элементе,
превосходящем опорный.
В итоге окажется, что что левее от left все элементы точно принадлежат первой
группе, а правее от right — второй. Элементы, на которых стоят указатели,
нарушают порядок.
Поменяем их местами (в большинстве языков программирования используется
функция swap()) и продвинем указатели на следующие элементы.
Будем повторять это действие до тех пор, пока left и right не столкнутся.
На рисунке представлен пример разделения при pivot=5.
Указатель left — голубой, right — оранжевый.
"""


from collections import namedtuple


def input_data():
    n = int(input())
    student_mask = namedtuple('student', ['tasks', 'penalty', 'login'])
    arr = [None] * n
    for idx in range(n):
        login, tasks, penalty = input().split()
        arr[idx] = student_mask(
            login=login, tasks=-int(tasks), penalty=int(penalty)
            )
    return arr


def partition(arr, left, right):
    ind_pivot = right - 1
    arr[left], arr[ind_pivot] = arr[ind_pivot], arr[left]
    pivot = arr[left]
    i, j = left + 1, left + 1

    while j <= right:
        if arr[j] <= pivot:
            arr[j], arr[i] = arr[i], arr[j]
            i += 1
        j += 1

    arr[left], arr[i - 1] = arr[i - 1], arr[left]
    return i - 1


def quick_sort(arr, left=0, right=None):
    if right is None:
        right = len(arr) - 1

    if right - left < 1:
        return

    middle = partition(arr, left, right)
    quick_sort(arr, left, middle - 1)
    quick_sort(arr, middle + 1, right)


def main():
    arr = input_data()
    quick_sort(arr)
    for student in arr:
        print(student.login)


if __name__ == '__main__':
    main()
